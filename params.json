{"name":"Optparse-applicative","tagline":"Applicative option parser","body":"# Applicative option parser\r\n\r\nThis package contains utilities and combinators to define command line option\r\nparsers.\r\n\r\n[![Continuous Integration status][status-png]][status]\r\n\r\n[Hackage page (downloads and documentation)][hackage]\r\n\r\n## Getting started\r\n\r\nHere is a simple example of an applicative option parser:\r\n\r\n```haskell\r\ndata Sample = Sample\r\n  { hello :: String\r\n  , quiet :: Bool }\r\n\r\nsample :: Parser Sample\r\nsample = Sample\r\n     <$> strOption\r\n         ( long \"hello\"\r\n        <> metavar \"TARGET\"\r\n        <> help \"Target for the greeting\" )\r\n     <*> switch\r\n         ( long \"quiet\"\r\n        <> help \"Whether to be quiet\" )\r\n```\r\n\r\nThe parser is built using [applicative style][applicative] starting from a set\r\nof basic combinators. In this example, `hello` is defined as an option with a\r\n`String` argument, while `quiet` is a boolean flag (called `switch`).\r\n\r\nA parser can be used like this:\r\n\r\n```haskell\r\ngreet :: Sample -> IO ()\r\ngreet (Sample h False) = putStrLn $ \"Hello, \" ++ h\r\ngreet _ = return ()\r\n\r\nmain :: IO ()\r\nmain = execParser opts >>= greet\r\n  where\r\n    opts = info (helper <*> sample)\r\n      ( fullDesc\r\n     <> progDesc \"Print a greeting for TARGET\"\r\n     <> header \"hello - a test for optparse-applicative\" )\r\n```\r\n\r\nThe `greet` function is the entry point of the program, while `opts` is a\r\ncomplete description of the program, used when generating a help text. The\r\n`helper` combinator takes any parser, and adds a `help` option to it.\r\n\r\nThe `hello` option in this example is mandatory (since it doesn't have a\r\ndefault value), so running the program without any argument will display a\r\nshort option summary:\r\n\r\n    Usage: hello --hello TARGET [--quiet]\r\n\r\nRunning the program with the `--help` option will display the full help text:\r\n\r\n    hello - a test for optparse-applicative\r\n\r\n    Usage: hello --hello TARGET [--quiet]\r\n      Print a greeting for TARGET\r\n\r\n    Available options:\r\n      -h,--help                Show this help text\r\n      --hello TARGET           Target for the greeting\r\n      --quiet                  Whether to be quiet\r\n\r\ncontaining a detailed list of options with descriptions.\r\n\r\nThe specified metavars are used as placeholders for the option arguments, and\r\ncan be referred to in the program description.  This makes it possible to\r\nexplicitly describe the connection between the options and the behaviour of the\r\nprogram.\r\n\r\nParsers are instances of both `Applicative` and `Alternative`, and work with\r\nany generic combinator, like `many` and `some`. For example, to make a option\r\nreturn `Nothing` instead of failing when it's not supplied, you can use the\r\n`optional` combinator in `Control.Applicative`:\r\n\r\n```haskell\r\noptional $ strOption\r\n   ( long \"output\"\r\n  <> metavar \"DIRECTORY\" )\r\n```\r\n\r\n [applicative]: http://www.soi.city.ac.uk/~ross/papers/Applicative.html\r\n\r\n## Supported options\r\n\r\n`optparse-applicative` supports four kinds of options: regular options, flags,\r\narguments and commands.\r\n\r\n### Regular options\r\n\r\nA **regular option** is an option which takes a single argument, parses it, and\r\nreturns a value.\r\n\r\nA regular option can have a default value, which is used as the result if the\r\noption is not found in the command line. An option without a default value is\r\nconsidered mandatory, and produces an error when not found.\r\n\r\nRegular options can have **long** names, or **short** (one-character) names,\r\nwhich determine when the option matches and how the argument is extracted.\r\n\r\nAn option with a long name (say \"output\") is specified on the command line as\r\n\r\n    --output filename.txt\r\n\r\nor\r\n\r\n    --output=filename.txt\r\n\r\nwhile a short name option (say \"o\") can be specified with\r\n\r\n    -o filename.txt\r\n\r\nor\r\n\r\n    -ofilename.txt\r\n\r\nOptions can have more than one name, usually one long and one short, although\r\nyou are free to create options with an arbitrary combination of long and short\r\nnames.\r\n\r\nRegular options returning strings are the most common, and they can be created\r\nusing the `strOption` builder. For example,\r\n\r\n```haskell\r\nstrOption\r\n   ( long \"output\"\r\n  <> short 'o'\r\n  <> metavar \"FILE\"\r\n  <> help \"Write output to FILE\" )\r\n```\r\n\r\ncreates a regular option with a string argument (which can be referred to as\r\n`FILE` in the help text and documentation), a long name \"output\" and a short\r\nname \"o\". See below for more information on the builder syntax and modifiers.\r\n\r\nA regular option can return an object of any type, and takes a *reader*\r\nparameter which specifies how the argument should be parsed.  A common reader is\r\n`auto`, which assumes a `Read` instance for the return type and uses it to parse\r\nits argument. For example:\r\n\r\n```haskell\r\nlineCount :: Parser Int\r\nlineCount = option auto\r\n            ( long \"lines\"\r\n           <> short 'n'\r\n           <> metavar \"K\"\r\n           <> help \"Output the last K lines\" )\r\n```\r\n\r\nspecifies a regular option with an `Int` argument. We added an explicit type\r\nannotation here, since without it the parser would have been polymorphic in the\r\noutput type. There's usually no need to add type annotations, however, because\r\nthe type will be normally inferred from the context in which the parser is\r\nused.\r\n\r\nYou can also create a custom reader that doesn't use the `Read` typeclass, and\r\nuse it to parse option arguments:\r\n\r\n```haskell\r\ndata FluxCapacitor = ...\r\n\r\nparseFluxCapacitor :: Monad m => String -> m FluxCapacitor\r\n\r\noption parseFluxCapacitor\r\n  ( long \"flux-capacitor\" )\r\n```\r\n\r\n### Flags\r\n\r\nA **flag** is just like a regular option, but it doesn't take any arguments: it is\r\neither present in the command line or not.\r\n\r\nA flag has a default value and an **active value**. If the flag is found on the\r\ncommand line, the active value is returned, otherwise the default value is\r\nused. For example:\r\n\r\n```haskell\r\ndata Verbosity = Normal | Verbose\r\n\r\nflag Normal Verbose\r\n  ( long \"verbose\"\r\n <> short 'v'\r\n <> help \"Enable verbose mode\" )\r\n```\r\n\r\nis a flag parser returning a `Verbosity` value.\r\n\r\nSimple boolean flags can be specified using the `switch` builder, like so:\r\n\r\n```haskell\r\nswitch\r\n  ( long \"keep-tmp-files\"\r\n <> help \"Retain all intermediate temporary files\" )\r\n```\r\n\r\nThere is also a `flag'` builder, which has no default value. For example, to\r\nadd a `--version` switch to a program, you could write:\r\n\r\n```haskell\r\nflag' Nothing (long \"version\" <> hidden) <|> (Just <$> normal_options)\r\n```\r\n\r\n### Arguments\r\n\r\nAn **argument** parser specifies a positional command line argument.\r\n\r\nThe `argument` builder takes a reader parameter, and creates a parser which\r\nwill return the parsed value every time it is passed a command line argument\r\nfor which the reader succeeds. For example\r\n\r\n```haskell\r\nargument str (metavar \"FILE\")\r\n```\r\n\r\ncreates an argument accepting any string.  To accept an arbitrary number of\r\narguments, combine the `argument` builder with either the `many` or `some`\r\ncombinator:\r\n\r\n```haskell\r\nsome (argument str (metavar \"FILES...\"))\r\n```\r\n\r\nArguments are only displayed in the brief help text, so there's no need to\r\nattach a description to them. They should be manually documented in the program\r\ndescription.\r\n\r\nNote that arguments starting with `-` are considered options by default, and\r\nwill not be considered by an `argument` parser.\r\n\r\nHowever, parsers always accept a special argument: `--`. When a `--` is found on\r\nthe command line, all the following words are considered by `argument` parsers,\r\nregardless of whether they start with `-` or not.\r\n\r\n### Commands\r\n\r\nA **command** can be used to specify a sub-parser to be used when a certain\r\nstring is encountered in the command line.\r\n\r\nCommands are useful to implement command line programs with multiple functions,\r\neach with its own set of options, and possibly some global options that apply\r\nto all of them. Typical examples are version control systems like `git`, or\r\nbuild tools like `cabal`.\r\n\r\nA command can be created using the `subparser` builder, and commands can be\r\nadded with the `command` modifier. For example\r\n\r\n```haskell\r\nsubparser\r\n  ( command \"add\" (info addOptions\r\n      ( progDesc \"Add a file to the repository\" ))\r\n <> command \"commit\" (info commitOptions\r\n      ( progDesc \"Record changes to the repository\" ))\r\n)\r\n```\r\n\r\nEach command takes a full `ParserInfo` structure, which will be used to extract\r\na description for this command when generating a help text.\r\n\r\nNote that all the parsers appearing in a command need to have the same type.\r\nFor this reason, it is often best to use a sum type which has the same\r\nstructure as the command itself. For example, for the parser above, you would\r\ndefine a type like:\r\n\r\n```haskell\r\ndata Options = Options\r\n  { optGlobalOpt :: String\r\n  , optGlobalFlag :: Bool\r\n  ...\r\n  , optCommand :: Command }\r\n\r\ndata Command\r\n  = Add AddOptions\r\n  | Commit CommitOptions\r\n  ...\r\n```\r\n\r\nAlternatively, you can directly return an `IO` action from a parser, and\r\nexecute it using `join` from `Control.Monad`.\r\n\r\n```haskell\r\nstart :: String -> IO ()\r\nstop :: IO ()\r\n\r\nopts :: Parser (IO ())\r\nopts = subparser\r\n  ( command \"start\" (info (start <$> argument str idm) idm)\r\n <> command \"stop\"  (info (pure stop) idm) )\r\n\r\nmain :: IO ()\r\nmain = join $ execParser (info opts idm)\r\n```\r\n\r\n## Option builders\r\n\r\nBuilders allow you to define parsers using a convenient combinator-based\r\nsyntax. Each builder takes a **modifier** as parameter, and returns a parser.\r\n\r\nA modifier is a composition of functions which act on the option, setting\r\nvalues for properties or adding features, and is used to build the option from\r\nscratch and finally lift it to a single-option parser, which can then be\r\ncombined with other parsers using normal `Applicative` combinators.\r\n\r\nModifiers are instances of the `Monoid` typeclass, so they can be combined\r\nusing the composition function `mappend` (or simply `(<>)`).\r\n\r\nSee the [haddock documentation][builder-documentation] for `Options.Applicative.Builder`\r\nfor a full list of builders and modifiers.\r\n\r\n## Advanced features\r\n\r\n* [Bash completion]\r\n* [Arrow interface]\r\n* [Disambiguation]\r\n\r\n [Bash completion]: https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion\r\n [Arrow interface]: https://github.com/pcapriotti/optparse-applicative/wiki/Arrows\r\n [Disambiguation]: https://github.com/pcapriotti/optparse-applicative/wiki/Disambiguation\r\n\r\n## How it works\r\n\r\nA `Parser a` is essentially a heterogeneous list of `Option`s, implemented with\r\nexistential types.\r\n\r\nAll options are therefore known statically (i.e. before parsing, not\r\nnecessarily before runtime), and can, for example, be traversed to generate a\r\nhelp text.\r\n\r\nSee [this blog post][blog] for a more detailed explanation based on a\r\nsimplified implementation.\r\n\r\n [status-png]: https://secure.travis-ci.org/pcapriotti/optparse-applicative.png?branch=master\r\n [status]: http://travis-ci.org/pcapriotti/optparse-applicative?branch=master\r\n [blog]: http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/\r\n [builder-documentation]: http://hackage.haskell.org/package/optparse-applicative/docs/Options-Applicative-Builder.html\r\n [hackage]: http://hackage.haskell.org/package/optparse-applicative\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}